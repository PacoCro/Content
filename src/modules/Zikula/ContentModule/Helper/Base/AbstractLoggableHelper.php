<?php
/**
 * Content.
 *
 * @copyright Axel Guckelsberger (Zikula)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Axel Guckelsberger <info@ziku.la>.
 * @link https://ziku.la
 * @version Generated by ModuleStudio 1.3.2 (https://modulestudio.de).
 */

namespace Zikula\ContentModule\Helper\Base;

use Doctrine\Common\Persistence\Event\LifecycleEventArgs;
use Doctrine\ORM\Id\AssignedGenerator;
use Doctrine\ORM\Mapping\ClassMetadata;
use Zikula\Core\Doctrine\EntityAccess;
use Zikula\ContentModule\Entity\Factory\EntityFactory;
use Zikula\ContentModule\Helper\TranslatableHelper;
use Zikula\ContentModule\Listener\EntityLifecycleListener;

/**
 * Helper base class for loggable behaviour.
 */
abstract class AbstractLoggableHelper
{
    /**
     * @var EntityFactory
     */
    protected $entityFactory;
    
    /**
     * @var EntityLifecycleListener
     */
    protected $entityLifecycleListener;
    
    /**
     * @var TranslatableHelper
     */
    protected $translatableHelper;
    
    /**
     * LoggableHelper constructor.
     *
     * @param EntityFactory $entityFactory EntityFactory service instance
     * @param EntityLifecycleListener $entityLifecycleListener Entity lifecycle subscriber
     * @param TranslatableHelper $translatableHelper TranslatableHelper service instance
     */
    public function __construct(
        EntityFactory $entityFactory,
        EntityLifecycleListener $entityLifecycleListener,
        TranslatableHelper $translatableHelper
    ) {
        $this->entityFactory = $entityFactory;
        $this->entityLifecycleListener = $entityLifecycleListener;
        $this->translatableHelper = $translatableHelper;
    }
    
    /**
     * Determines template parameters for diff view.
     *
     * @param array $logEntries List of log entries for currently treated entity instance
     *
     * @return array
     */
    public function determineDiffViewParameters($logEntries)
    {
        $minVersion = $maxVersion = 0;
        if ($versions[0] < $versions[1]) {
            $minVersion = $versions[0];
            $maxVersion = $versions[1];
        } else {
            $minVersion = $versions[1];
            $maxVersion = $versions[0];
        }
        $logEntries = array_reverse($logEntries);
    
        $diffValues = [];
        foreach ($logEntries as $logEntry) {
            if (null === $logEntry->getData()) {
                continue;
            }
            foreach ($logEntry->getData() as $field => $value) {
                if (!isset($diffValues[$field])) {
                    $diffValues[$field] = [
                        'old' => '',
                        'new' => '',
                        'changed' => false
                    ];
                }
                if (is_array($value)) {
                    $value = is_array(reset($value)) ? 'Array' : implode(', ', $value);
                }
                if ($logEntry->getVersion() <= $minVersion) {
                    $diffValues[$field]['old'] = $value;
                    $diffValues[$field]['new'] = $value;
                } elseif ($logEntry->getVersion() <= $maxVersion) {
                    $diffValues[$field]['new'] = $value;
                    $diffValues[$field]['changed'] = $diffValues[$field]['new'] != $diffValues[$field]['old'];
                }
            }
        }
    
        return [$minVersion, $maxVersion, $diffValues];
    }
    
    /**
     * Return name of the version field for the given object type.
     *
     * @param string $objectType Currently treated entity type
     *
     * @return string
     */
    public function getVersionFieldName($objectType = '')
    {
        $versionFieldMap = [
            'page' => 'currentVersion',
        ];
    
        return isset($versionFieldMap[$objectType]) ? $versionFieldMap[$objectType] : '';
    }
    
    /**
     * Checks whether a history may be shown for the given entity instance.
     *
     * @param EntityAccess $entity Currently treated entity instance
     *
     * @return boolean
     */
    public function hasHistoryItems($entity)
    {
        $objectType = $entity->get_objectType();
        $versionField = $this->getVersionFieldName($objectType);
        $getter = 'get' . ucfirst($versionField);
    
        /** alternative (with worse performance)
         * $entityManager = $this->entityFactory->getObjectManager();
         * $logEntriesRepository = $entityManager->getRepository('ZikulaContentModule:' . ucfirst($objectType) . 'LogEntryEntity');
         * $logEntries = $logEntriesRepository->getLogEntries($entity);
         * return count($logEntries) > 1;
         */
    
        return $entity->$getter() > 1;
    }
    
    /**
     * Checks whether deleted entities exist for the given object type.
     *
     * @param string $objectType Currently treated entity type
     *
     * @return boolean
     */
    public function hasDeletedEntities($objectType = '')
    {
        $entityManager = $this->entityFactory->getObjectManager();
        $logEntriesRepository = $entityManager->getRepository('ZikulaContentModule:' . ucfirst($objectType) . 'LogEntryEntity');
    
        return count($logEntriesRepository->selectDeleted(1)) > 0;
    }
    
    /**
     * Returns deleted entities for the given object type.
     *
     * @param string $objectType Currently treated entity type
     *
     * @return array
     */
    public function getDeletedEntities($objectType = '')
    {
        $entityManager = $this->entityFactory->getObjectManager();
        $logEntriesRepository = $entityManager->getRepository('ZikulaContentModule:' . ucfirst($objectType) . 'LogEntryEntity');
    
        return $logEntriesRepository->selectDeleted();
    }
    
    /**
     * Sets the given entity to back to a specific version.
     *
     * @param EntityAccess $entity           Currently treated entity instance
     * @param integer      $requestedVersion Target version
     * @param boolean      $detach           Whether to detach the entity or not
     *
     * @return EntityAccess The reverted entity instance
     */
    public function revert($entity, $requestedVersion = 1, $detach = false)
    {
        $entityManager = $this->entityFactory->getObjectManager();
        $objectType = $entity->get_objectType();
    
        $logEntriesRepository = $entityManager->getRepository('ZikulaContentModule:' . ucfirst($objectType) . 'LogEntryEntity');
        $logEntries = $logEntriesRepository->getLogEntries($entity);
        if (count($logEntries) < 2) {
            return $entity;
        }
    
        // revert to requested version
        $logEntriesRepository->revert($entity, $requestedVersion);
        if (true === $detach) {
            // detach the entity to avoid persisting it
            $entityManager->detach($entity);
        }
    
        $entity = $this->revertPostProcess($entity);
    
        return $entity;
    }
    
    /**
     * Resets a deleted entity back to the last version before it's deletion.
     *
     * @param string  $objectType Currently treated entity type
     * @param integer $id         The entity's identifier
     *
     * @return EntityAccess|null The restored entity instance
     */
    public function restoreDeletedEntity($objectType = '', $id = 0)
    {
        if (!$id) {
            return null;
        }
    
        $methodName = 'create' . ucfirst($objectType);
        $entity = $this->entityFactory->$methodName();
        $idField = $this->entityFactory->getIdField($objectType);
        $setter = 'set' . ucfirst($idField);
        $entity->$setter($id);
    
        $entityManager = $this->entityFactory->getObjectManager();
        $logEntriesRepository = $entityManager->getRepository('ZikulaContentModule:' . ucfirst($objectType) . 'LogEntryEntity');
        $logEntries = $logEntriesRepository->getLogEntries($entity);
        $lastVersionBeforeDeletion = null;
        foreach ($logEntries as $logEntry) {
            if ('remove' != $logEntry->getAction()) {
                $lastVersionBeforeDeletion = $logEntry->getVersion();
                break;
            }
        }
        if (null === $lastVersionBeforeDeletion) {
            return null;
        }
    
        $objectType = $entity->get_objectType();
        $versionField = $this->getVersionFieldName($objectType);
    
        $logEntriesRepository->revert($entity, $lastVersionBeforeDeletion);
        $versionSetter = 'set' . ucfirst($versionField);
        $entity->$versionSetter($lastVersionBeforeDeletion + 2);
    
        $entity = $this->revertPostProcess($entity);
    
        return $entity;
    }
    
    /**
     * Performs actions after reverting an entity to a previous revision.
     *
     * @param EntityAccess $entity Currently treated entity instance
     *
     * @return EntityAccess The processed entity instance
     */
    protected function revertPostProcess($entity)
    {
        $objectType = $entity->get_objectType();
    
        if (in_array($objectType, ['page'])) {
            // check if parent is still valid
            $repository = $this->entityFactory->getRepository($objectType);
            $parentId = $entity->getParent()->getId();
            $parent = $parentId ? $repository->find($parentId) : null;
            if (in_array('Doctrine\Common\Proxy\Proxy', class_implements($parent), true)) {
                // look for a root node to use as parent
                $parentNode = $repository->findOneBy(['lvl' => 0]);
                $entity->setParent($parentNode);
            }
        }
    
        if (in_array($objectType, ['page'])) {
            $entity = $this->translatableHelper->setEntityFieldsFromLogData($entity);
        }
    
        $eventArgs = new LifecycleEventArgs($entity, $this->entityFactory->getObjectManager());
        $this->entityLifecycleListener->postLoad($eventArgs);
    
        return $entity;
    }
    
    /**
     * Persists a formerly entity again.
     *
     * @param EntityAccess $entity Currently treated entity instance
     *
     * @return EntityAccess|null The restored entity instance
     *
     * @throws Exception If something goes wrong
     */
    public function undelete($entity)
    {
        $entityManager = $this->entityFactory->getObjectManager();
    
        $metadata = $entityManager->getClassMetaData(get_class($entity));
        $metadata->setIdGeneratorType(ClassMetadata::GENERATOR_TYPE_NONE);
        $metadata->setIdGenerator(new AssignedGenerator());
    
        $versionField = $metadata->versionField;
        $metadata->setVersioned(false);
        $metadata->setVersionField(null);
    
        $entityManager->persist($entity);
        $entityManager->flush($entity);
    
        $metadata->setVersioned(true);
        $metadata->setVersionField($versionField);
    }
}
